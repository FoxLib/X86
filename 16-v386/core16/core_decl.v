// ---------------------------------------------------------------------
// Именованные константы
// ---------------------------------------------------------------------

localparam
    fetch           = 0,
    fetch_modrm     = 1,
    exec            = 2,
    modrm_wb        = 3,
    fetch_imm16     = 4,
    loadseg         = 5,
    exception       = 6,
    push            = 7,
    pop             = 8,
    shift           = 9,
    interrupt       = 10,
    divide          = 11,
    portin          = 12,
    portout         = 13;

localparam
    CF = 0, PF = 2, AF =  4, ZF =  6, SF = 7,
    TF = 8, IF = 9, DF = 10, OF = 11,
    IOPL0   = 12,
    IOPL1   = 13,
    NT      = 14,
    RF      = 16,
    VM      = 17;

localparam
    alu_add = 3'h0, alu_or  = 3'h1,
    alu_adc = 3'h2, alu_sbb = 3'h3,
    alu_and = 3'h4, alu_sub = 3'h5,
    alu_xor = 3'h6, alu_cmp = 3'h7;

// ---------------------------------------------------------------------
// УПРАВЛЕНИЕ ПАМЯТЬЮ
// ---------------------------------------------------------------------

// Пока что режим REAL-MODE
assign address =
    src ? {segment[15:0], 4'h0} + ea[15:0] :
          {     cs[15:0], 4'h0} + ip[15:0];

initial begin

    we          = 1'b0;
    out         = 1'b0;
    port        = 1'b0;
    port_clk    = 1'b0;
    port_o      = 1'b0;
    port_w      = 1'b0;

end


// ---------------------------------------------------------------------
// РЕГИСТРЫ И СЕГМЕНТЫ
// ---------------------------------------------------------------------

// 8 x 32 битных регистров общего назначения
reg [15:0]  ax = 16'h707F;
reg [15:0]  bx = 16'hAABC;
reg [15:0]  cx = 16'h0002;
reg [15:0]  dx = 16'h0000;
reg [15:0]  sp = 16'hFFFE;
reg [15:0]  bp = 16'h0000;
reg [15:0]  si = 16'h0000;
reg [15:0]  di = 16'h0004;

//                       ODIT SZ A  P1C
reg [17:0]  flags  = 18'b0000_0000_0010;
reg [15:0]  ip     = 16'h0000;
reg [15:0]  ip_rep = 16'h0000;

reg [15:0]  es  = 16'hF000;
reg [15:0]  cs  = 16'hF000;
reg [15:0]  ss  = 16'h0000;
reg [15:0]  ds  = 16'hF800;
// ---------------------------------------------------------------------

reg [3:0]   t               = 1'b0;     // Фаза исполнения
reg [3:0]   t_next          = 1'b0;     // Переход к фазе после исполнения процедуры
reg [4:0]   fn              = 1'b0;     // Фаза exec
reg [3:0]   fn2             = 1'b0;     // Фаза процедур
reg [8:0]   opcode          = 1'b0;     // Сохраненный опкод
reg [2:0]   psize           = 1'b0;     // Количество префиксов от 0 до 7
reg [7:0]   modrm           = 1'b0;     // Сохраненный modrm
reg         src             = 1'b0;     // Источник адреса segment:ea; cs:ip
reg         src_next        = 1'b1;     // src после fetch_modrm
reg         trace_ff        = 1'b0;     // Trace вызывается после инструкции
reg [15:0]  segment         = 1'b0;     // Рабочий сегмент
reg [15:0]  ea              = 1'b0;     // Эффективный адрес
reg         override        = 1'b0;     // =1 Сегмент префиксирован
reg         ignoreo         = 1'b0;     // Игнорировать чтение из памяти modrm
reg [1:0]   rep             = 1'b0;     // Режим REPNZ/REPZ
reg [2:0]   alu             = 3'h0;     // Режим АЛУ
reg         size            = 1'b0;     // =1 16/32 битный операнд
reg         dir             = 1'b0;     // =0 rm,r; =1 r,rm modrm
reg [ 2:0]  regn            = 3'b0;     // reg32 = register[regn]
reg [15:0]  op1             = 16'h0;    // Левый операнд
reg [15:0]  op2             = 16'h0;    // Правый операнд
reg [15:0]  wb              = 16'h0;    // Значение для записи
reg [15:0]  frametemp       = 16'h0;    // ENTER

reg         __opext         = 1'b0;
reg         __override      = 1'b0;
reg [1:0]   __rep           = 2'b00;
reg [15:0]  __segment       = 16'hF800;

// ---------------------------------------------------------------------
// Модуль деления op1 / op2 -> divres | divrem
// ---------------------------------------------------------------------

reg [31:0]  diva            = 1'b0;
reg [31:0]  divb            = 1'b0;
reg [ 6:0]  divcnt          = 1'b0;
reg [31:0]  divrem          = 1'b0;
reg [31:0]  divres          = 1'b0;
reg         signa           = 1'b0;
reg         signb           = 1'b0;

wire        signd   = signa ^ signb;
wire [31:0] mult    = op1 * op2;
wire [15:0] aam     = ax[15:8] * in + ax[7:0];
wire [31:0] _diva   = size ? {dx, ax} : {ax, 16'h0};
wire [31:0] _divb   = size ? op1 : op1[7:0];
wire [31:0] _divr   = {divrem, diva[31]};

// ---------------------------------------------------------------------
// Вычисление следующего IP в зависимости от 54-го бита
// ---------------------------------------------------------------------

// ip / esp
wire [15:0] ip_next    = ip[15:0] + 1'b1;
wire [15:0] ip_next2   = ip[15:0] + 2'h2;
wire [15:0] ip_next3   = ip[15:0] + 2'h3;
wire [15:0] sp_dec     = sp[15:0] - 2'h2;
wire [15:0] sp_inc     = sp[15:0] + 2'h2;

// ---------------------------------------------------------------------
// Строковые инструкции, инкремементы и декременты
// ---------------------------------------------------------------------

// Приращение +/- 1,2,4;
wire [ 2:0] str_inc     = t == fetch ? (in[0] ? 2 : 1) : (opcode[0] ? 2 : 1);
wire [15:0] str_zcx     = cx[15:0];

// Следующий ESI:EDI:ECX
wire [15:0] str_si     = flags[DF] ? si - str_inc : si + str_inc;
wire [15:0] str_di     = flags[DF] ? di - str_inc : di + str_inc;
wire [15:0] str_cx     = cx - 1'b1;
// ---------------------------------------------------------------------
// Получение регистров
// ---------------------------------------------------------------------

// Извлечение регистра
wire [15:0] reg16 =
    regn == 3'd0 ? (size ? ax[15:0] : ax[ 7:0]) :
    regn == 3'd1 ? (size ? cx[15:0] : cx[ 7:0]) :
    regn == 3'd2 ? (size ? dx[15:0] : dx[ 7:0]) :
    regn == 3'd3 ? (size ? bx[15:0] : bx[ 7:0]) :
    regn == 3'd4 ? (size ? sp[15:0] : ax[15:8]) :
    regn == 3'd5 ? (size ? bp[15:0] : cx[15:8]) :
    regn == 3'd6 ? (size ? si[15:0] : dx[15:8]) :
                   (size ? di[15:0] : bx[15:8]);

